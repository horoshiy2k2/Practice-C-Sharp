using System;
using System.Collections.Generic;
using System.Text;

namespace SystemObject
{
    class Point
    {
        public int X { get; set; }

        public Point Y { get; set; }
        // переопределяем, чтобы по значению сравнение было
        // редко вообще используется
        //ПРАВИЛА:
        //1)Сравнение с самим собой = тру
        //2)A.Equals(B) === B.Equals(A)
        //3)A == B, B == C, то A == C
        //4)Переопределяем Equals - переопределяем == и != (копипаст)
        //5)GetHashCode реализовать
        public override bool Equals(object obj) // НЕ ДОЛЖЕН КИДАТЬ ЭКСЕПШН, наиболее оптимален
        { 
            if (obj is Point point) // obj приводит в point
            {
                return point.X == X;
            }
            else
            {
                return false;
            }
        }

        //Редко вообще используется
        //Хэшкоды разные - объекты разные. В обратную сторону неверно
        //Очень быстро вычисляет id объекта
        //Вполне возможно возникновение коллизии (наложение - одни и те же объекты могут иметь одинаковый хэшкод)
        public override int GetHashCode()
        {
            return X;
        }

        //Часто используется, в отладке
        //С секретной инфой так лучше не делать (в логи может утечь)
        public override string ToString()
        {
            return X.ToString(); // int.ToString()
        }

        // клон - доп. объект, содержащий все те же поля, что и в клонируемом, но это другой объект
        // Клонирование глубокое и неглубокое
        public Point Clone()
        {
            var result = (Point)MemberwiseClone(); // глубокое клонирование
            result.Y = Y.Clone(); // MyClass.Clone() - норм, а Y.Clone() - stackoverflow ^)
            // = new Point()


            //return MemberwiseClone() as Point; // неглубокое - значимые типы будут продублированы, все свойства и поля свои собственные
            // Но если есть ссылка на объект класса, то одна и та же будет в обоих экземплярах

            // Program:
            // a = new Point() {X = 5; instance1}
            // c = a.Clone()
            // c.x = 88 // a.x не измениться
            // с.y = instance2; // ссылочный тип был скопирован, поэтому ссылка осталась, поменяется в a
            // d = a.DeepClone() // ГЛУБОКОЕ копирование, вручную, сами определяем, что копируется
            // С помощью глубокого можно создавать абсолютно новые объекты
            // Неглубокое создаёт объект с новыми значимыми типами, но с одинаковыми ссылочными
        }

        //Не делать так, опасно
        //Перекрытие метода с помощью new. НЕ ПОЛИМОРФИЗМ. Намеренное скрытие. Не виртуальный метод перекрыть
        public new Type GetType()
        {
            return typeof(UInt16);
        }

    }
}
